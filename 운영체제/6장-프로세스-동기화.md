[TOC]

<br>

<br>

# [프로세스 동기화 #1](https://core.ewha.ac.kr/publicview/C0101020140401134252676046?vmode=f)

### 데이터의 접근

- Data는 I/O 장치 등을 통해 외부에서 들어옴.

- 연산은 컴퓨터 내부의 CPU에서 이루어짐.

- 연산은 항상 외부의 데이터를 받은 뒤에 이루어진다.

- 연산 결과는 다시 외부로 반환된다.

  ![2](6장-프로세스-동기화.assets/2.JPG)

<br>

### Race Condition

- 데이터를 여러 군데에서 동시에 접근해서 연산을 하게 되면 문제가 생김.

- 아래 그림의 경우, 언뜻 보기에는 count가 다시 원래대로 돌아올 것 같지만 ```count--```가 ```count++``` 이전의 원래 값을 가져갔기에 count는 감소한 상태가 된다.

- CPU가 하나만 있다고 꼭 이런 문제가 안 생기는 것은 아님!

- 그렇가도 CPU가 여러 개라고 해서 꼭 이런 문제가 생기는 것은 아니다!

- 문제가 생기는 이유 : 운영체제가 끼어드는 경우

  - 프로세스는 시스템 콜을 통해 본인이 못 하는 일을 운영체제에게 대신 해달라고 요청할 수가 있음.

  - 만약 프로세스 A가 시스템 콜을 하는 타이밍과 프로세스 B가 시스템 콜을 하는 타이밍이 겹치면, 운영체제가 동일한 데이터를 다루는 과정에서 Race Condition이 일어날 수 있음.

    ![3](6장-프로세스-동기화.assets/3.JPG)

<br>

### OS에서의 Race Condition

- 언제 발생하는가?

  1. kernel 수행 중 인터럽트 발생 시
  2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
  3. Multiprocessor에서 shared memory 내의 kernel data

- 사례

  ![4](6장-프로세스-동기화.assets/4.JPG)

  ![5](6장-프로세스-동기화.assets/5-1631409912599.JPG)

  ![6](6장-프로세스-동기화.assets/6.JPG)

  ![7](6장-프로세스-동기화.assets/7.JPG)

  - 위 사진의 방법 1은 오버헤드가 많이 듦!

- 추가 해결방안

  - Shared Memory를 사용해서 데이터 상황을 공유하는 방안이 있다.

<br>

### Process Synchronization 문제

- 공유 데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다.
- 일관성(consistency) 유지를 위해서는 협력 프로세스(cooperating process) 간의 **실행 순서(orderly execution)**를 정해주는 메커니즘 필요
- Race condition
  - 여러 프로세스 들이 동시에 공유 데이터를 접근하는 상황
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- race condition을 막기 위해서는 concurrent process는 동기화(synchronize)되어야 한다.

- Example of a Race Condition

  ![8](6장-프로세스-동기화.assets/8.JPG)

- The Critical-Section Problem

  - n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우

  - 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재

  - Problem

    - 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

    - 이걸 구현하기 위해 critial-section에 lock을 거는 방법이 있다.

      ![9](6장-프로세스-동기화.assets/9.JPG)

<br>

### 프로그램적 해결법의 충족조건

- Mutual Exclusion (상호 배제)
  - 프로세스 Pi가 Critical Section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 Critical Section에 들어가면 안 된다.
- Progress (진행)
  - 아무도 Critical Section에 있지 않은 상태에서 Critical Section에 들어가고자 하는 프로세스가 있으면 Critical Section에 들어가게 해주어야 한다.
- Bounded Waiting (유한대기)
  - 프로세스가 Critical Section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에 한계가 있어야 한다.
- 가정
  - 모든 프로세스의 수행 속도는 0보다 크다.
  - 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.

- Initial Attempts to Solve Problem

  ![1](6장-프로세스-동기화.assets/1.JPG)

<br>

### Algorithm 1

- 이 알고리즘을 사용하면 두 프로세스가 동시에 Critical Section에 들어가는 일은 없음.

- 그러나 프로세스가 반드시 Critical Section에 번갈아 들어가야 하기에, 내 프로세스가 들어가기 위해서는 반드시 상대 프로세스가 끝날 때까지 기다려야 한다는 단점이 있음.

- 따라서 내 프로세스가 자주 Critical Section에 들어가고, 상대방은 자주 Critical Section에 들어가지 않는다면 내 차례가 돌아오지 않는다는 문제점이 발생한다.

- 충족 조건에서 상호 배제는 충족했지만 진행을 충족하지 못했다.

  ![1](6장-프로세스-동기화.assets/1-1631426530513.JPG)

<br>

### Algorithm 2

- flag를 사용하는 알고리즘

  - flag를 통해 동시 접근을 막는다.
  - flag를 통해 접근 의사를 표현한다.
  - Critical Section을 들어갔나 나오면 flag 변수가 무조건 false가 된다.

- 상호 배제는 충족하지만 진행을 충족하지 못 한다.

  - flag 변수가 true인 것은 Critical Section에 들어가겠다는 의사를 표현한 것이지,  Critical Section에 들어갔다는 뜻이 아니다.

  - 그런데 상대방의 flag 변수가 true인 것만 보고 Critical Section에 들어가 있다는 착각을 하여, 아무도 Critical Section에 들어가 있지 않는데 어느 프로세스도 Critical Section을 이용하지 못하는 문제가 발생할 수 있다.

     ![2](6장-프로세스-동기화.assets/2-1631427392197.JPG)

<br>

### Algorithm 3 (Peterson's Algorithm)

- Algorithm 1과 Algorithm 2의 변수들이 모두 활용됨

- flag 변수가 true인 상황에 한해서 turn을 진행시킨다.

- 문제점

  - 기다리면서 계속 CPU를 사용하며 자원을 낭비하는 문제가 발생한다.

    ![4](6장-프로세스-동기화.assets/4-1631427757481.JPG)

<br>

### Synchronization Hardware

- Test_and_set()

  - 변수를 읽고 변수값을 세팅하는 과정을 atomic하게 수행

    ![5](6장-프로세스-동기화.assets/5-1631427996936.JPG)

<br>

<br>

# [프로세스 동기화 #2](https://core.ewha.ac.kr/publicview/C0101020140404151340260748?vmode=f)

### Semaphores

- 일종의 추상 자료형

- P 연산 : 자원을 획득하는 과정

- V 연산 : 자원을 반납하는 과정

- 자원은 공유 자원으로, 자원을 사용하는 코드가 P 연산과 V 연산 사이에 오게 된다.

  ![6](6장-프로세스-동기화.assets/6-1631428263456.JPG)

<br>

### Critical Section of n Processes

- semaphore 변수를 사용 : 1로 초기화

- semaphore가 지원되면 Critical Section 문제를 효율적으로 해결할 수 있다.

- semaphore 변수가 0이면 CPU를 바로 반납하게 하는(blocked 상태) 방식으로 busy-wait 문제를 해결할 수 있다.

  ![7](6장-프로세스-동기화.assets/7-1631428672290.JPG)

<br>

### Block / Wakeup Implementation

- semaphore 변수들을 잠재워서 줄 세운다.

  ![8](6장-프로세스-동기화.assets/8-1631428760247.JPG)

- P 연산 시 무조건 1을 뺀다.

- V 연산 시 무조건 1을 증가시킨다. 

  - 이 때, 값이 꼭 양수가 된다는 보장이 없다!
  - 값이 음수면 누군가가 이 세마포어를 기다리면서 잠들고 있다는 뜻이다.
  - 값이 양수면 세마포어가 남아돌아서 어느 누구도 쓰고 싶어하지 않는 상황이다.

- 따라서 여기서의 S의 값은 자원의 양을 의미하는 것이 아니다.

  ![9](6장-프로세스-동기화.assets/9-1631428982145.JPG)

<br>

### Whick is better?

- Block/Wakeup 방식이 일반적으로는 더 좋다.

- Critical Section의 길이마 매우 짧은 경우에는 Busy-Wait 방식이 더 좋다.

- Critical Section의 길이보다는, Critical Section에 대한 경쟁이 치열한가 아닌가로 비교하는 것이 더 정확하다.

  ![10](6장-프로세스-동기화.assets/10.JPG)

<br>

### Two Types of Semaphores

- Counting semaphore
  - 도메인이 0 이상인 임의의 정수값
  - 주로 resource counting에 사용
- Binary semaphore (=mutex)
  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 mutual exclusion(lock/unlock)에 사용

<br>

### Deadlock and Starvation

- 

<br>

<br>

# [프로세스 동기화 #3](https://core.ewha.ac.kr/publicview/C0101020140408134626290222?vmode=f)

<br>

<br>

# [프로세스 동기화 #4](https://core.ewha.ac.kr/publicview/C0101020140411143154161543?vmode=f)

### Classical Problems of Syncronization

- Bounded-Buffer Problem (Producer-Consumer Problem)
- Readers-Writers Problem
- Dining-Philosophers Problem

<br>

### Monitor

- 